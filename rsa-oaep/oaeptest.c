#include <stdio.h>
#include <string.h>
#include "hash.h"
#include "mgf.h"
#include "rand.h"
#include "oaep.h"

// 测试数据来自文档: 《RSAES-OAEP Encryption Scheme》, 附录 C. Test Vectors
// https://www.inf.pucrs.br/~calazans/graduate/TPVLSI_I/RSA-oaep_spec.pdf

/*
 * RSA Key Information
 */
// n, the modulus
static char n[] = {
    0xbb, 0xf8, 0x2f, 0x09, 0x06, 0x82, 0xce, 0x9c, 0x23, 0x38, 0xac, 0x2b, 0x9d, 0xa8, 0x71, 0xf7,
    0x36, 0x8d, 0x07, 0xee, 0xd4, 0x10, 0x43, 0xa4, 0x40, 0xd6, 0xb6, 0xf0, 0x74, 0x54, 0xf5, 0x1f,
    0xb8, 0xdf, 0xba, 0xaf, 0x03, 0x5c, 0x02, 0xab, 0x61, 0xea, 0x48, 0xce, 0xeb, 0x6f, 0xcd, 0x48,
    0x76, 0xed, 0x52, 0x0d, 0x60, 0xe1, 0xec, 0x46, 0x19, 0x71, 0x9d, 0x8a, 0x5b, 0x8b, 0x80, 0x7f,
    0xaf, 0xb8, 0xe0, 0xa3, 0xdf, 0xc7, 0x37, 0x72, 0x3e, 0xe6, 0xb4, 0xb7, 0xd9, 0x3a, 0x25, 0x84,
    0xee, 0x6a, 0x64, 0x9d, 0x06, 0x09, 0x53, 0x74, 0x88, 0x34, 0xb2, 0x45, 0x45, 0x98, 0x39, 0x4e,
    0xe0, 0xaa, 0xb1, 0x2d, 0x7b, 0x61, 0xa5, 0x1f, 0x52, 0x7a, 0x9a, 0x41, 0xf6, 0xc1, 0x68, 0x7f,
    0xe2, 0x53, 0x72, 0x98, 0xca, 0x2a, 0x8f, 0x59, 0x46, 0xf8, 0xe5, 0xfd, 0x09, 0x1d, 0xbd, 0xcb
};

// e, the public exponent
static unsigned long e = 0x11; /* 17 */

// p, the first prime factor of n
static char p[] =
{
    0xee, 0xcf, 0xae, 0x81, 0xb1, 0xb9, 0xb3, 0xc9, 0x08, 0x81, 0x0b, 0x10, 0xa1, 0xb5, 0x60, 0x01,
    0x99, 0xeb, 0x9f, 0x44, 0xae, 0xf4, 0xfd, 0xa4, 0x93, 0xb8, 0x1a, 0x9e, 0x3d, 0x84, 0xf6, 0x32,
    0x12, 0x4e, 0xf0, 0x23, 0x6e, 0x5d, 0x1e, 0x3b, 0x7e, 0x28, 0xfa, 0xe7, 0xaa, 0x04, 0x0a, 0x2d,
    0x5b, 0x25, 0x21, 0x76, 0x45, 0x9d, 0x1f, 0x39, 0x75, 0x41, 0xba, 0x2a, 0x58, 0xfb, 0x65, 0x99
};

// q, the second prime factor of n
static char q[] =
{
    0xc9, 0x7f, 0xb1, 0xf0, 0x27, 0xf4, 0x53, 0xf6, 0x34, 0x12, 0x33, 0xea, 0xaa, 0xd1, 0xd9, 0x35,
    0x3f, 0x6c, 0x42, 0xd0, 0x88, 0x66, 0xb1, 0xd0, 0x5a, 0x0f, 0x20, 0x35, 0x02, 0x8b, 0x9d, 0x86,
    0x98, 0x40, 0xb4, 0x16, 0x66, 0xb4, 0x2e, 0x92, 0xea, 0x0d, 0xa3, 0xb4, 0x32, 0x04, 0xb5, 0xcf,
    0xce, 0x33, 0x52, 0x52, 0x4d, 0x04, 0x16, 0xa5, 0xa4, 0x41, 0xe7, 0x00, 0xaf, 0x46, 0x15, 0x03
};

// dP, p’s exponent:
static char dP[] =
{
    0x54, 0x49, 0x4c, 0xa6, 0x3e, 0xba, 0x03, 0x37, 0xe4, 0xe2, 0x40, 0x23, 0xfc, 0xd6, 0x9a, 0x5a,
    0xeb, 0x07, 0xdd, 0xdc, 0x01, 0x83, 0xa4, 0xd0, 0xac, 0x9b, 0x54, 0xb0, 0x51, 0xf2, 0xb1, 0x3e,
    0xd9, 0x49, 0x09, 0x75, 0xea, 0xb7, 0x74, 0x14, 0xff, 0x59, 0xc1, 0xf7, 0x69, 0x2e, 0x9a, 0x2e,
    0x20, 0x2b, 0x38, 0xfc, 0x91, 0x0a, 0x47, 0x41, 0x74, 0xad, 0xc9, 0x3c, 0x1f, 0x67, 0xc9, 0x81
};

// dQ, q’s exponent:
static char dQ[] =
{
    0x47, 0x1e, 0x02, 0x90, 0xff, 0x0a, 0xf0, 0x75, 0x03, 0x51, 0xb7, 0xf8, 0x78, 0x86, 0x4c, 0xa9,
    0x61, 0xad, 0xbd, 0x3a, 0x8a, 0x7e, 0x99, 0x1c, 0x5c, 0x05, 0x56, 0xa9, 0x4c, 0x31, 0x46, 0xa7,
    0xf9, 0x80, 0x3f, 0x8f, 0x6f, 0x8a, 0xe3, 0x42, 0xe9, 0x31, 0xfd, 0x8a, 0xe4, 0x7a, 0x22, 0x0d,
    0x1b, 0x99, 0xa4, 0x95, 0x84, 0x98, 0x07, 0xfe, 0x39, 0xf9, 0x24, 0x5a, 0x98, 0x36, 0xda, 0x3d
};

// qInv, the CRT coefficient
static char qInv[] =
{
    0xb0, 0x6c, 0x4f, 0xda, 0xbb, 0x63, 0x01, 0x19, 0x8d, 0x26, 0x5b, 0xdb, 0xae, 0x94, 0x23, 0xb3,
    0x80, 0xf2, 0x71, 0xf7, 0x34, 0x53, 0x88, 0x50, 0x93, 0x07, 0x7f, 0xcd, 0x39, 0xe2, 0x11, 0x9f,
    0xc9, 0x86, 0x32, 0x15, 0x4f, 0x58, 0x83, 0xb1, 0x67, 0xa9, 0x67, 0xbf, 0x40, 0x2b, 0x4e, 0x9e,
    0x2e, 0x0f, 0x96, 0x56, 0xe6, 0x98, 0xea, 0x36, 0x66, 0xed, 0xfb, 0x25, 0x79, 0x80, 0x39, 0xf7
};

/*
 * Intermedia Values for RSA Encryption
 */
// M, the message to be encrypted
static char M[] =
{
    0xd4, 0x36, 0xe9, 0x95, 0x69, 0xfd, 0x32, 0xa7, 0xc8, 0xa0, 0x5b, 0xbc, 0x90, 0xd3, 0x2c, 0x49
};

// P, encoding parameters
static char *P = ""; // P = NULL;

// pHash = Hash(P) = SHA1(P)
// $ echo -n "" | sha1sum | awk '{print $1}' | xxd -r -ps | xxd -i -c 16
//   0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
//   0xaf, 0xd8, 0x07, 0x09
static char pHash[] =
{
    0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
    0xaf, 0xd8, 0x07, 0x09
};

// DB = pHash || PS || 01 || M
static char DB[] =
{
    0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55, 0xbf, 0xef, 0x95, 0x60, 0x18, 0x90,
    0xaf, 0xd8, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd4, 0x36, 0xe9, 0x95, 0x69,
    0xfd, 0x32, 0xa7, 0xc8, 0xa0, 0x5b, 0xbc, 0x90, 0xd3, 0x2c, 0x49
};

// seed, a random octet string
static char seed[] =
{
    0xaa, 0xfd, 0x12, 0xf6, 0x59, 0xca, 0xe6, 0x34, 0x89, 0xb4, 0x79, 0xe5, 0x07, 0x6d, 0xde, 0xc2,
    0xf0, 0x6c, 0xb5, 0x8f
};

// dbMask = MGF1(seed, 107)
static char dbMask[] =
{
    0x06, 0xe1, 0xde, 0xb2, 0x36, 0x9a, 0xa5, 0xa5, 0xc7, 0x07, 0xd8, 0x2c, 0x8e, 0x4e, 0x93, 0x24,
    0x8a, 0xc7, 0x83, 0xde, 0xe0, 0xb2, 0xc0, 0x46, 0x26, 0xf5, 0xaf, 0xf9, 0x3e, 0xdc, 0xfb, 0x25,
    0xc9, 0xc2, 0xb3, 0xff, 0x8a, 0xe1, 0x0e, 0x83, 0x9a, 0x2d, 0xdb, 0x4c, 0xdc, 0xfe, 0x4f, 0xf4,
    0x77, 0x28, 0xb4, 0xa1, 0xb7, 0xc1, 0x36, 0x2b, 0xaa, 0xd2, 0x9a, 0xb4, 0x8d, 0x28, 0x69, 0xd5,
    0x02, 0x41, 0x21, 0x43, 0x58, 0x11, 0x59, 0x1b, 0xe3, 0x92, 0xf9, 0x82, 0xfb, 0x3e, 0x87, 0xd0,
    0x95, 0xae, 0xb4, 0x04, 0x48, 0xdb, 0x97, 0x2f, 0x3a, 0xc1, 0x4e, 0xaf, 0xf4, 0x9c, 0x8c, 0x3b,
    0x7c, 0xfc, 0x95, 0x1a, 0x51, 0xec, 0xd1, 0xdd, 0xe6, 0x12, 0x64
};

// maskedDB = DB ^ dbMask
static char maskedDB[] =
{
    0xdc, 0xd8, 0x7d, 0x5c, 0x68, 0xf1, 0xee, 0xa8, 0xf5, 0x52, 0x67, 0xc3, 0x1b, 0x2e, 0x8b, 0xb4,
    0x25, 0x1f, 0x84, 0xd7, 0xe0, 0xb2, 0xc0, 0x46, 0x26, 0xf5, 0xaf, 0xf9, 0x3e, 0xdc, 0xfb, 0x25,
    0xc9, 0xc2, 0xb3, 0xff, 0x8a, 0xe1, 0x0e, 0x83, 0x9a, 0x2d, 0xdb, 0x4c, 0xdc, 0xfe, 0x4f, 0xf4,
    0x77, 0x28, 0xb4, 0xa1, 0xb7, 0xc1, 0x36, 0x2b, 0xaa, 0xd2, 0x9a, 0xb4, 0x8d, 0x28, 0x69, 0xd5,
    0x02, 0x41, 0x21, 0x43, 0x58, 0x11, 0x59, 0x1b, 0xe3, 0x92, 0xf9, 0x82, 0xfb, 0x3e, 0x87, 0xd0,
    0x95, 0xae, 0xb4, 0x04, 0x48, 0xdb, 0x97, 0x2f, 0x3a, 0xc1, 0x4f, 0x7b, 0xc2, 0x75, 0x19, 0x52,
    0x81, 0xce, 0x32, 0xd2, 0xf1, 0xb7, 0x6d, 0x4d, 0x35, 0x3e, 0x2d
};

// seedMask = MGF(maskedDB, 20)
static char seedMask[] =
{
    0x41, 0x87, 0x0b, 0x5a, 0xb0, 0x29, 0xe6, 0x57, 0xd9, 0x57, 0x50, 0xb5, 0x4c, 0x28, 0x3c, 0x08,
    0x72, 0x5d, 0xbe, 0xa9
};

// maskedSeed = seed ^ seedMask
static char maskedSeed[] =
{
    0xeb, 0x7a, 0x19, 0xac, 0xe9, 0xe3, 0x00, 0x63, 0x50, 0xe3, 0x29, 0x50, 0x4b, 0x45, 0xe2, 0xca,
    0x82, 0x31, 0x0b, 0x26
};

// EM = maskedSeed || maskedDB
//      eb 7a 19 ac e9 e3 00 63 50 e3 29 50 4b 45 e2 ca 82 31 0b 26 dc d8 7d 5c
//      68 f1 ee a8 f5 52 67 c3 1b 2e 8b b4 25 1f 84 d7 e0 b2 c0 46 26 f5 af f9
//      3e dc fb 25 c9 c2 b3 ff 8a e1 0e 83 9a 2d db 4c dc fe 4f f4 77 28 b4 a1
//      b7 c1 36 2b aa d2 9a b4 8d 28 69 d5 02 41 21 43 58 11 59 1b e3 92 f9 82
//      fb 3e 87 d0 95 ae b4 04 48 db 97 2f 3a c1 4f 7b c2 75 19 52 81 ce 32 d2
//      f1 b7 6d 4d 35 3e 2d
// /*
//  * No pre 0x00 in EM in the document, for PKCS #1 v2.2, a 0x00 should be added
//  */

static char EM[] =
{
    0x00, 0xeb, 0x7a, 0x19, 0xac, 0xe9, 0xe3, 0x00, 0x63, 0x50, 0xe3, 0x29, 0x50, 0x4b, 0x45, 0xe2,
    0xca, 0x82, 0x31, 0x0b, 0x26, 0xdc, 0xd8, 0x7d, 0x5c, 0x68, 0xf1, 0xee, 0xa8, 0xf5, 0x52, 0x67,
    0xc3, 0x1b, 0x2e, 0x8b, 0xb4, 0x25, 0x1f, 0x84, 0xd7, 0xe0, 0xb2, 0xc0, 0x46, 0x26, 0xf5, 0xaf,
    0xf9, 0x3e, 0xdc, 0xfb, 0x25, 0xc9, 0xc2, 0xb3, 0xff, 0x8a, 0xe1, 0x0e, 0x83, 0x9a, 0x2d, 0xdb,
    0x4c, 0xdc, 0xfe, 0x4f, 0xf4, 0x77, 0x28, 0xb4, 0xa1, 0xb7, 0xc1, 0x36, 0x2b, 0xaa, 0xd2, 0x9a,
    0xb4, 0x8d, 0x28, 0x69, 0xd5, 0x02, 0x41, 0x21, 0x43, 0x58, 0x11, 0x59, 0x1b, 0xe3, 0x92, 0xf9,
    0x82, 0xfb, 0x3e, 0x87, 0xd0, 0x95, 0xae, 0xb4, 0x04, 0x48, 0xdb, 0x97, 0x2f, 0x3a, 0xc1, 0x4f,
    0x7b, 0xc2, 0x75, 0x19, 0x52, 0x81, 0xce, 0x32, 0xd2, 0xf1, 0xb7, 0x6d, 0x4d, 0x35, 0x3e, 0x2d
};

// C, the RSA encryption of EM
static char C[] =
{
    0x12, 0x53, 0xe0, 0x4d, 0xc0, 0xa5, 0x39, 0x7b, 0xb4, 0x4a, 0x7a, 0xb8, 0x7e, 0x9b, 0xf2, 0xa0,
    0x39, 0xa3, 0x3d, 0x1e, 0x99, 0x6f, 0xc8, 0x2a, 0x94, 0xcc, 0xd3, 0x00, 0x74, 0xc9, 0x5d, 0xf7,
    0x63, 0x72, 0x20, 0x17, 0x06, 0x9e, 0x52, 0x68, 0xda, 0x5d, 0x1c, 0x0b, 0x4f, 0x87, 0x2c, 0xf6,
    0x53, 0xc1, 0x1d, 0xf8, 0x23, 0x14, 0xa6, 0x79, 0x68, 0xdf, 0xea, 0xe2, 0x8d, 0xef, 0x04, 0xbb,
    0x6d, 0x84, 0xb1, 0xc3, 0x1d, 0x65, 0x4a, 0x19, 0x70, 0xe5, 0x78, 0x3b, 0xd6, 0xeb, 0x96, 0xa0,
    0x24, 0xc2, 0xca, 0x2f, 0x4a, 0x90, 0xfe, 0x9f, 0x2e, 0xf5, 0xc9, 0xc1, 0x40, 0xe5, 0xbb, 0x48,
    0xda, 0x95, 0x36, 0xad, 0x87, 0x00, 0xc8, 0x4f, 0xc9, 0x13, 0x0a, 0xde, 0xa7, 0x4e, 0x55, 0x8d,
    0x51, 0xa7, 0x4d, 0xdf, 0x85, 0xd8, 0xb5, 0x0d, 0xe9, 0x68, 0x38, 0xd6, 0x06, 0x3e, 0x09, 0x55
};

/*
 * Intermedia Values for RSA Decryption
 */
// c mod p (c is the integer value of C)
static char cmp[] =
{
    0xde, 0x63, 0xd4, 0x72, 0x35, 0x66, 0xfa, 0xa7, 0x59, 0xbf, 0xe4, 0x08, 0x82, 0x1d, 0xd5, 0x25,
    0x72, 0xec, 0x92, 0x85, 0x4d, 0xdf, 0x87, 0xa2, 0xb6, 0x64, 0xd4, 0x4d, 0xaa, 0x37, 0xca, 0x34,
    0x6a, 0x05, 0x20, 0x3d, 0x82, 0xff, 0x2d, 0xe8, 0xe3, 0x6c, 0xec, 0x1d, 0x34, 0xf9, 0x8e, 0xb6,
    0x05, 0xe2, 0xa7, 0xd2, 0x6d, 0xe7, 0xaf, 0x36, 0x9c, 0xe4, 0xec, 0xae, 0x14, 0xe3, 0x56, 0x33
};

// c mod q
static char cmq[] =
{
    0xa2, 0xd9, 0x24, 0xde, 0xd9, 0xc3, 0x6d, 0x62, 0x3e, 0xd9, 0xa6, 0x5b, 0x5d, 0x86, 0x2c, 0xfb,
    0xec, 0x8b, 0x19, 0x9c, 0x64, 0x27, 0x9c, 0x54, 0x14, 0xe6, 0x41, 0x19, 0x6e, 0xf1, 0xc9, 0x3c,
    0x50, 0x7a, 0x9b, 0x52, 0x13, 0x88, 0x1a, 0xad, 0x05, 0xb4, 0xcc, 0xfa, 0x02, 0x8a, 0xc1, 0xec,
    0x61, 0x42, 0x09, 0x74, 0xbf, 0x16, 0x25, 0x83, 0x6b, 0x0b, 0x7d, 0x05, 0xfb, 0xb7, 0x53, 0x36
};

// m1 = c^(dP) mod p = (c mod p)^(dP) mod p
static char m1[] =
{
    0x89, 0x6c, 0xa2, 0x6c, 0xd7, 0xe4, 0x87, 0x1c, 0x7f, 0xc9, 0x68, 0xa8, 0xed, 0xea, 0x11, 0xe2,
    0x71, 0x82, 0x4f, 0x0e, 0x03, 0x65, 0x52, 0x17, 0x94, 0xf1, 0xe9, 0xe9, 0x43, 0xb4, 0xa4, 0x4b,
    0x57, 0xc9, 0xe3, 0x95, 0xa1, 0x46, 0x74, 0x78, 0xf5, 0x26, 0x49, 0x6b, 0x4b, 0xb9, 0x1f, 0x1c,
    0xba, 0xea, 0x90, 0x0f, 0xfc, 0x60, 0x2c, 0xf0, 0xc6, 0x63, 0x6e, 0xba, 0x84, 0xfc, 0x9f, 0xf7
};

// m2 = c^(dQ) mod q = (c mod q)^(dQ) mod q
static char m2[] =
{
    0x4e, 0xbb, 0x22, 0x75, 0x85, 0xf0, 0xc1, 0x31, 0x2d, 0xca, 0x19, 0xe0, 0xb5, 0x41, 0xdb, 0x14,
    0x99, 0xfb, 0xf1, 0x4e, 0x27, 0x0e, 0x69, 0x8e, 0x23, 0x9a, 0x8c, 0x27, 0xa9, 0x6c, 0xda, 0x9a,
    0x74, 0x09, 0x74, 0xde, 0x93, 0x7b, 0x5c, 0x9c, 0x93, 0xea, 0xd9, 0x46, 0x2c, 0x65, 0x75, 0x02,
    0x1a, 0x23, 0xd4, 0x64, 0x99, 0xdc, 0x9f, 0x6b, 0x35, 0x89, 0x75, 0x59, 0x60, 0x8f, 0x19, 0xbe
};

// h = (m1 − m2)^(qInv) mod p
static char h[] =
{
    0x01, 0x2b, 0x2b, 0x24, 0x15, 0x0e, 0x76, 0xe1, 0x59, 0xbd, 0x8d, 0xdb, 0x42, 0x76, 0xe0, 0x7b,
    0xfa, 0xc1, 0x88, 0xe0, 0x8d, 0x60, 0x47, 0xcf, 0x0e, 0xfb, 0x8a, 0xe2, 0xae, 0xbd, 0xf2, 0x51,
    0xc4, 0x0e, 0xbc, 0x23, 0xdc, 0xfd, 0x4a, 0x34, 0x42, 0x43, 0x94, 0xad, 0xa9, 0x2c, 0xfc, 0xbe,
    0x1b, 0x2e, 0xff, 0xbb, 0x60, 0xfd, 0xfb, 0x03, 0x35, 0x9a, 0x95, 0x36, 0x8d, 0x98, 0x09, 0x25
};

// m = m2 + qh is equal to the integer value of the encoded message EM above.
// The intermediate values of the decoding operation are similar to those of the encoding operation.

int Get_Random_Bytes(char *buf, unsigned long len)
{
    memcpy(buf, seed, 20);

    return 0;
}

/*
 * cc oaeptest.c oaep.c -o oaeptest -I../out/include -L../out/lib -lhash -lmgf
 */
int main(int argc, char *argv[])
{
    unsigned long k, mLen;
    char buf_em[1024], buf_msg[1024];
    int i, res;

    k = sizeof(n)/sizeof(n[0]);
    mLen = sizeof(M)/sizeof(M[0]);

    // 生成 label L 的哈希
    printf("M= ");
    for (i=0; i<20; i++)
    {
        printf("%02x", ((unsigned char *)M)[i]);
    }
    printf("\n");

    // 生成 label L 的哈希
    HASH(HASH_ALG_SHA1, "", 0, buf_em);
    printf("Hash(\"\")= ");
    for (i=0; i<20; i++)
    {
        printf("%02x", ((unsigned char *)buf_em)[i]);
    }
    printf("\n\n");

    /*
     * OAEP Encoding Test
     */
    printf("Encoding Test: \n");
    OAEP_Encoding(HASH_ALG_SHA1, k, M, mLen, "", 0, buf_em, k);
    printf("Encoding: \n");
    for (i=0; i<k; i++)
    {
        printf("0x%02x ", ((unsigned char *)buf_em)[i]);
        if (i % 16 == 15)
        {
            printf("\n");
        }
    }
    printf("\n");

    printf("Expect: \n");
    for (i=0; i<k; i++)
    {
        printf("0x%02x ", ((unsigned char *)EM)[i]);
        if (i % 16 == 15)
        {
            printf("\n");
        }
    }
    printf("\n");

    /*
     * OAEP Decoding Test
     */
    printf("Decoding Test:\n");
    res = OAEP_Decoding(HASH_ALG_SHA1, k, "", 0, buf_em, k, buf_msg, &mLen);
    if (-1 == res)
    {
        printf("decoding error\n");
    }
    else
    {
        printf("Decoding: \n");
        for (i=0; i<mLen; i++)
        {
            printf("0x%02x ", ((unsigned char *)buf_msg)[i]);
            if (i % 16 == 15)
            {
                printf("\n");
            }
        }
        printf("\n");

        printf("Expect: \n");
        for (i=0; i<sizeof(M)/sizeof(M[0]); i++)
        {
            printf("0x%02x ", ((unsigned char *)M)[i]);
            if (i % 16 == 15)
            {
                printf("\n");
            }
        }
        printf("\n");
    }

    return 0;
}
/*

1. 生成 RSA Private Key

$ openssl genrsa -outform=PEM -out rsa_private_key.pem -f4 2048
$ cat rsa_private_key.pem
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEAyQtipu9UPSIEpyyspheuxaduAUhfliNTEtPq/4VPft2RU8Oz
rBSsZk4lTlCkJVaTNxPAhldOLYKqdlDr4DU0vrYH9AJ3NOsny33ETIzHkgVN/8FI
29j6amssZVv0JOaXpxsp760EsFPj3/JTuxBDb7M6ndHZat7P3qDb1TJ/RPCnGBWf
aLV2NXllx8WwaZVYnYhgvU+UWhGjoqJlxb4JENBFhTl0CzgH7oe/aIzrPIuBoSci
U1JbP2YgOxMEBo15d+vL7J5wm7C17HZPkeHaoTXoyKFkD0gCdlhBCUe8OJpji1yS
3aBnanBktWsHhD6EriaHLTD+4G3d2OkwtUKwXwIDAQABAoIBADhM8O6Q3UVVbnom
f57vyOjfL2Y6j1IrSEtgf1HZUl7Ty6vqhTlufK0Vu0rIOH+gVA+7f1HfxyvliLkj
hjq+i6vQrD+AJUPziqxo5v0M+6J/y80Qose2ZsJAiylDbAadcODCMadGC6cZhxoi
8aHUNx5j0cl6h+luxkWxRH7a6lsyjkfNvtk6HY5cEUh7kbRDR2eVEljs6UBlYbFN
o381xf+EcYYBHpYK+eJwyLkzkNsnj8fRsI4CR7Vdy5I0tObfXLOraH+GfAgiwLgC
rf3pD3ntHIGrWvcVWzGsEJDDH3KMAjrt/0nihbCjh3VPLFtMtwUldiJxe2k97GXD
oeaikYkCgYEA75Wc0R0KlxsAHFrhBUH0FGL+jFB7JZqb9NnBk/fLSE5dExsFAtoT
jCuMNSizFXeUPg3bcgOoT9J5gTq0BROhNj1AZM+FMcx4Sc6suv8RYqcukohO6vL0
raDWxFmxybj1je0ORIKn9X0+EhBwCRreEsSIoMy8WC/gEeaKRj/9/aUCgYEA1tHF
DdwtHQBBadWbpQifTezIJ0fAKafkPRt917FkPIk583VQHz3CGr4pNKkag6S9Fb+o
6ptdsYuQALY+c789SE5Zfmw+XnNJpqX2d5gHyKDKceaM6L/szgUKDiGQj2XcQXFG
wb2MY/1VBpk6Ewj9i17ur8wE7J5DNEXzZ3ZdHrMCgYEAkyZVFqq7omtW+hNnOY90
lkDnDs8vk70OJKjKGFONa2+WAvIJdeLzNphYmR3SQFEdn69rJO/SJJSlRBYGE0gn
L+UW89PxftCS4OIrfP7Ecs8z75QAxJVMaofq4NYmODt9thnvNWz6M/EkenvWFAGI
fAZx1DFrTM661MPAEb2kBnECgYEAkJyKQPhVTk6bunlX29NgGn8phnfgvqoNFa3q
G0eJqM7gOiphE4bpokMdThwAg1plB70MI1MP0bOX70K/6/9za7eCu352xfJqREs5
De1EYCUN43tGpHB/I3l0+WpS/JWfnlZ5QXcuiSlDEbwYwjOtKyNvHt0C+57Wstvc
LWwa580CgYEAyQDOL29qGXOtb1JzcpOIbNu96CtZU2jLEGHjPi2KCT8FfdqtcTbH
F+Cq5RdRYmIhSuEF7NAXVqMBpghsW8n+vbdKh5EkSgF5PqLhrLbb3oW1kS9RgnPt
w4fZbvOUDBTCeIPKnsV2zSM2VGsWeqdxZ1bQncHvjl4vQg9mGxOZVKs=
-----END RSA PRIVATE KEY-----

2. 从私钥导出 Public Key

$ openssl rsa -inform PEM -in rsa_private_key.pem -pubout -out rsa_public_key.pem

3. 使用 Public Key 加密消息

$ echo -n "I Love China!" | openssl rsautl  -encrypt -pubin -inkey rsa_public_key.pem -oaep -out cipher_msg.bin
$ hexdump -Cv cipher_msg.bin
00000000  7b f8 ee d0 07 5b c2 2c  d1 15 c6 75 21 54 73 30  |{....[.,...u!Ts0|
00000010  66 6e 78 97 02 7f fa 83  46 27 34 b0 ff 6b de ab  |fnx.....F'4..k..|
00000020  e2 e4 24 67 1f 1a 4e e5  a5 bf b5 91 d8 0b 6a 6a  |..$g..N.......jj|
00000030  4e 81 08 74 fa b7 07 db  c6 7c 93 63 aa d3 2b 70  |N..t.....|.c..+p|
00000040  a1 bf 2b cd 01 94 e8 39  a4 23 12 41 68 b2 7f 2c  |..+....9.#.Ah..,|
00000050  4f 6e 3a 7a bf de 24 42  3b 21 84 c3 4b 50 22 9e  |On:z..$B;!..KP".|
00000060  6c 04 41 c8 a9 b3 81 73  be f6 15 c3 9d 5c 7b 48  |l.A....s.....\{H|
00000070  a8 c0 70 54 94 a0 de 9e  8d 1c 99 7a ac 79 68 0b  |..pT.......z.yh.|
00000080  43 73 21 6c 4c 38 3e 92  2f c7 22 98 82 77 4b af  |Cs!lL8>./."..wK.|
00000090  11 27 e6 ff 86 e4 0c 8b  28 70 87 4c 43 46 4b eb  |.'......(p.LCFK.|
000000a0  b4 ce de a5 70 00 fe 42  24 5e bf e4 fb 02 3a b0  |....p..B$^....:.|
000000b0  1f b6 1f 7d 9a c9 ff 49  8a b1 cf 3a 12 ba 65 6d  |...}...I...:..em|
000000c0  b3 ad df b2 87 4f 7f 51  07 0b 7d f2 82 5d ef 40  |.....O.Q..}..].@|
000000d0  67 62 41 05 45 f6 31 e3  18 e6 50 51 5d af 13 62  |gbA.E.1...PQ]..b|
000000e0  13 8f b0 cd 15 d6 e3 eb  5d 05 ef 33 9a 57 62 6b  |........]..3.Wbk|
000000f0  48 c4 1c 27 b5 b9 0e 34  55 4f 4d 3f 8c 93 3c 38  |H..'...4UOM?..<8|
00000100

4. 使用 Private Key 解密消息

$ openssl rsautl -decrypt -inkey rsa_private_key.pem -oaep -in cipher_msg.bin | xxd -g 1
00000000: 49 20 4c 6f 76 65 20 43 68 69 6e 61 21           I Love China!

5. 使用 Private Key 解密获取原始的消息内容

$ openssl rsautl -decrypt -inkey rsa_private_key.pem -oaep -in cipher_msg.bin -raw -hexdump
0000 - 00 4a 8e 3f 7f d7 3d c8-06 ce fb fb 0b 20 d1 7b   .J.?..=...... .{
0010 - 3a 27 90 2b 71 64 d5 27-de 50 20 0d be 50 2a 02   :'.+qd.'.P ..P*.
0020 - d0 3e 7a 2c c2 d3 39 41-f8 4e c0 de 97 54 93 eb   .>z,..9A.N...T..
0030 - a5 f1 28 78 1a 2f 96 88-26 7e fc 36 e1 6e 4b e2   ..(x./..&~.6.nK.
0040 - e5 44 e3 3e 6b d3 6a e9-6a 36 fa ae 7a a8 98 49   .D.>k.j.j6..z..I
0050 - 23 99 95 f1 ea 41 6d 6e-a0 d8 ce e7 ab 5d b9 db   #....Amn.....]..
0060 - 5b 38 48 bf 11 b0 1f 72-f8 ee 90 ce 9d 0c 00 fe   [8H....r........
0070 - 56 dd 4f 65 97 82 b3 ea-8b 6e 74 4e 75 12 06 c6   V.Oe.....ntNu...
0080 - e8 ab 88 2a fd 54 3d ac-d9 fe 44 27 6b 8d 3e 28   ...*.T=...D'k.>(
0090 - 07 df e2 33 48 69 8d 14-f2 71 89 d6 8d 0f d4 65   ...3Hi...q.....e
00a0 - 84 a7 5a 1e 63 c6 26 e3-29 0f e0 dc b5 71 f6 9e   ..Z.c.&.)....q..
00b0 - 12 7e 41 ff 76 69 28 e3-9e d3 97 2d 49 74 27 f0   .~A.vi(....-It'.
00c0 - 30 a7 a1 da 67 fa 14 bd-22 7d e8 9a 8a 52 c7 da   0...g..."}...R..
00d0 - 7f 8e 12 de ad b0 d5 99-48 3d d0 c6 aa 14 47 e2   ........H=....G.
00e0 - 27 e3 85 66 a0 39 e9 3b-52 1e 8c 57 c1 5c 5e 0c   '..f.9.;R..W.\^.
00f0 - aa d7 43 9f b9 16 0b 05-54 a4 18 27 c4 a3 d5 b4   ..C.....T..'....


# 使用 pkeyutl 指定 MGF 函数和 OAEP 填充的 hash 算法
$ echo -n "I Love China!" | openssl pkeyutl -encrypt -inkey rsa_private_key.pem -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha1 -pkeyopt rsa_mgf1_md:sha1 -out cipher2.bin
$ hexdump -Cv cipher2.bin
00000000  13 27 a3 86 0d 7e 9e b2  20 d3 26 16 9a c0 1c 19  |.'...~.. .&.....|
00000010  9a b5 7c 7d 20 02 58 fa  85 de 7e 72 81 7e ed 08  |..|} .X...~r.~..|
00000020  fb c5 54 51 f4 be c0 b7  3d 15 38 d6 a7 a7 63 cc  |..TQ....=.8...c.|
00000030  3c 00 c4 62 d9 40 bb 0f  8d 4d d0 21 a8 e1 9e 13  |<..b.@...M.!....|
00000040  c3 bc 08 6f 46 44 37 fc  7f 28 a5 b5 6c 31 39 28  |...oFD7..(..l19(|
00000050  01 03 4a 93 c4 02 4b f3  d7 a8 54 58 c9 c0 f0 bc  |..J...K...TX....|
00000060  3d 08 98 89 b4 17 4e ef  0c 84 66 51 ac 66 28 16  |=.....N...fQ.f(.|
00000070  21 78 d1 bd a6 0d d5 7f  27 0d 3d 1d 14 b1 63 e0  |!x......'.=...c.|
00000080  32 fc 43 3e bf 04 57 34  8c e3 6c 3e 90 7f 27 c1  |2.C>..W4..l>..'.|
00000090  28 0c 6f d2 ca 0e 77 16  ad 5c c7 3b 62 52 73 a9  |(.o...w..\.;bRs.|
000000a0  2e 8c 4c ec 9b ad ce 98  b5 bf 1c 8a 14 52 ba e4  |..L..........R..|
000000b0  46 00 9e f9 e0 dd 5b 11  46 69 aa a0 5c fa e7 96  |F.....[.Fi..\...|
000000c0  a7 ac c4 c5 09 5c 67 95  16 98 92 aa 5a 79 30 b1  |.....\g.....Zy0.|
000000d0  9a 8a 44 d7 7a e6 b4 ff  fa 68 98 7b 08 03 51 59  |..D.z....h.{..QY|
000000e0  96 df 55 9e 25 c6 4b 07  bc fe 69 2b 11 69 4f 8e  |..U.%.K...i+.iO.|
000000f0  8b c3 8d 15 fe 55 8b 97  1a 35 d1 42 95 42 1f c1  |.....U...5.B.B..|
00000100
$ openssl pkeyutl -decrypt -inkey rsa_private_key.pem -pkeyopt rsa_padding_mode:oaep -pkeyopt rsa_oaep_md:sha1 -pkeyopt rsa_mgf1_md:sha1 -in cipher2.bin -hexdump
0000 - 49 20 4c 6f 76 65 20 43-68 69 6e 61 21            I Love China!
*/